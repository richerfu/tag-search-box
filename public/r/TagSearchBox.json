{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "TagSearchBox",
  "type": "registry:component",
  "dependencies": [
    "clone",
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "card",
    "checkbox",
    "command",
    "dialog",
    "dropdown-menu",
    "input",
    "label",
    "popover",
    "scroll-area",
    "textarea",
    "tooltip",
    "utils"
  ],
  "files": [
    {
      "path": "src/registry/new-york/tag-search-box/index.ts",
      "content": "export * from \"./TagSearchBox\";",
      "type": "registry:component",
      "target": "src/components/tag-search-box/index.ts"
    },
    {
      "path": "src/registry/new-york/tag-search-box/TagSearchBox.tsx",
      "content": "import React, { Component, createRef, forwardRef } from \"react\";\nimport clone from \"clone\";\nimport { Tag, TagValue } from \"@/registry/new-york/tag-search-box/Tag\";\nimport { TagInput } from \"@/registry/new-york/tag-search-box/TagInput\";\nimport { mergeRefs } from \"@/registry/new-york/tag-search-box/utils/MergeRefs\";\nimport { TagSearchBoxContext } from \"@/registry/new-york/tag-search-box/TagSearchboxContext\";\nimport { withOutsideClick } from \"@/registry/new-york/tag-search-box/utils/withOutsideClick\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { X, Info, Search } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { AttributeValue } from \"@/registry/new-york/tag-search-box/AttributeSelect\";\n\nexport type { AttributeValue };\n\n/**\n * 焦点所在位置类型\n */\nexport enum FocusPosType {\n  INPUT = 0,\n  INPUT_EDIT = 1,\n  TAG = 2,\n}\n\nlet COUNTER = 0;\n\ninterface TagSearchBoxProps {\n  /**\n   * 要选择过滤的资源属性的集合\n   */\n  attributes?: AttributeValue[];\n  /**\n   * 搜索框中默认包含的标签值的集合\n   */\n  defaultValue?: TagValue[];\n  /**\n   * 配合 onChange 作为受控组件使用\n   */\n  value?: TagValue[];\n  /**\n   * 当新增/修改/减少标签时调用此函数\n   *\n   * **💡 用于触发搜索**\n   */\n  onChange?: (tags: TagValue[]) => void;\n  /**\n   * 搜索框收起后宽度\n   * @default 210\n   */\n  minWidth?: string | number;\n  /**\n   * 是否禁用\n   * @default false\n   * @since 2.4.1\n   */\n  disabled?: boolean;\n  /**\n   * 搜索框中提示语\n   *\n   * @default \"多个关键字用竖线 \"|\" 分隔，多个过滤标签用回车键分隔\" （已处理国际化）\n   */\n  tips?: string;\n  /**\n   * 资源属性选择下拉框提示\n   *\n   * @default \"选择资源属性进行过滤\" （已处理国际化）\n   */\n  attributesSelectTips?: string;\n  /**\n   * 隐藏帮助按钮\n   *\n   * @default false\n   */\n  hideHelp?: boolean;\n  /**\n   * 清空按钮点击回调\n   *\n   * @since 2.2.2\n   */\n  onClearButtonClick?: (e: React.MouseEvent) => void;\n  /**\n   * 帮助按钮点击回调\n   *\n   * 返回 `false` 阻止默认提示行为\n   *\n   * @since 2.2.2\n   */\n  onHelpButtonClick?: (e: React.MouseEvent) => void | false;\n  /**\n   * 搜索按钮点击回调\n   *\n   * @since 2.2.2\n   */\n  onSearchButtonClick?: (e: React.MouseEvent, value: TagValue[]) => void;\n  /**\n   * 禁用根据输入值过滤资源属性选项\n   *\n   * **新增或修改标签时将展示全部资源属性**\n   *\n   * @since 2.4.0\n   * @default false\n   */\n  disableAttributesFilter?: boolean;\n  /**\n   * 删除单个标签的回调\n   *\n   * 返回 `false` 阻止删除\n   *\n   * @since 2.7.4\n   */\n  onDeleteTag?: (tag: TagValue) => Promise<boolean> | boolean;\n}\n\ninterface TagSearchBoxState {\n  active: boolean;\n  curPos: number;\n  curPosType: FocusPosType;\n  showSelect: boolean;\n  tags: TagValue[];\n  lastValue?: TagValue[];\n}\n\nclass ITagSearchBox extends Component<\n  TagSearchBoxProps & {\n    forwardRef?: React.Ref<HTMLDivElement>;\n  },\n  TagSearchBoxState\n> {\n  static displayName = \"TagSearchBox\";\n\n  private searchWrapRef = createRef<HTMLDivElement>();\n  private searchBoxRef = createRef<HTMLDivElement>();\n  private tagRefs: { [key: string]: any } = {};\n\n  constructor(props: TagSearchBoxProps) {\n    super(props);\n    this.tagRefs = {};\n\n    const { defaultValue = [], value } = props;\n    const initialTags = defaultValue.map((item) => {\n      const newItem = clone(item);\n      // @ts-ignore\n      newItem[\"_key\"] = COUNTER++;\n      return newItem;\n    });\n\n    this.state = {\n      active: false,\n      curPos: 0,\n      curPosType: FocusPosType.INPUT,\n      showSelect: true,\n      tags: initialTags,\n      lastValue: value,\n    };\n  }\n\n  componentDidUpdate(prevProps: TagSearchBoxProps) {\n    const { value } = this.props;\n    if (value !== prevProps.value) {\n      const tagValue =\n        value?.map((item) => {\n          const newItem = clone(item);\n          if (!(\"_key\" in newItem)) {\n            // @ts-ignore\n            newItem[\"_key\"] = COUNTER++;\n          }\n          return newItem;\n        }) || [];\n\n      this.setState({\n        tags: clone(tagValue),\n        lastValue: value,\n      });\n    }\n  }\n\n  // 重置标签状态\n  private resetTagsState = (\n    props: TagSearchBoxProps,\n    callback?: () => void\n  ) => {\n    if (\"value\" in props) {\n      const tagValue =\n        props.value?.map((item) => {\n          const newItem = clone(item);\n          if (!(\"_key\" in newItem)) {\n            // @ts-ignore\n            newItem[\"_key\"] = COUNTER++;\n          }\n          return newItem;\n        }) || [];\n\n      this.setState({ tags: clone(tagValue) }, () => {\n        if (callback) setTimeout(callback, 0);\n      });\n    }\n  };\n\n  // 打开搜索框\n  open = () => {\n    const { disabled } = this.props;\n    const { active, tags = [] } = this.state;\n\n    if (disabled) {\n      return;\n    }\n\n    if (!active) {\n      this.setState({ active: true });\n      this.setState({ curPosType: FocusPosType.INPUT, curPos: tags.length });\n    } else {\n      this.handleTagEvent(\"click-input\", tags.length);\n    }\n    this.setState({ showSelect: true });\n\n    setTimeout(() => {\n      this.tagRefs[`tag-${tags.length}`]?.moveToEnd();\n    }, 100);\n  };\n\n  // 关闭搜索框\n  close = () => {\n    const { active, tags } = this.state;\n    const updatedTags = tags.map((item, index) => {\n      const newItem = clone(item);\n      // @ts-ignore\n      if (newItem[\"_edit\"]) {\n        this.tagRefs[`tag-${index}`]?.editDone();\n        // @ts-ignore\n        newItem[\"_edit\"] = false;\n      }\n      return newItem;\n    });\n\n    this.setTags(\n      updatedTags,\n      () => {\n        this.setState({ showSelect: false }, () => {\n          if (active) {\n            this.setState({ active: false }, () => {\n              this.setState({ curPos: -1 });\n              if (this.searchBoxRef.current) {\n                this.searchBoxRef.current.scrollLeft = 0;\n              }\n            });\n          }\n        });\n      },\n      false\n    );\n  };\n\n  // 获取标签值\n  private getValue = (tags: TagValue[]) => {\n    const result: TagValue[] = [];\n\n    tags.forEach((item) => {\n      const { values, attr = undefined } = item;\n      if (values && values.length > 0) {\n        result.push({\n          attr,\n          values,\n          // @ts-ignore\n          _key: item[\"_key\"],\n          // @ts-ignore\n          _edit: item[\"_edit\"],\n        });\n      }\n    });\n\n    return result;\n  };\n\n  // 通知变更\n  private notify = (tags: TagValue[]) => {\n    const { onChange = () => {} } = this.props;\n    onChange(this.getValue(tags));\n  };\n\n  // 设置标签状态\n  private setTags = (\n    newTags: TagValue[],\n    callback?: (() => void) | null,\n    shouldNotify = true\n  ) => {\n    const { value } = this.props;\n    const cb = () => {\n      if (shouldNotify) {\n        this.notifyChange(newTags);\n      }\n      if (callback) {\n        callback();\n      }\n    };\n\n    // 受控模式\n    if (shouldNotify && value) {\n      this.resetTagsState(this.props, cb);\n    } else {\n      this.setState({ tags: newTags }, () => {\n        setTimeout(cb, 0);\n      });\n    }\n  };\n\n  // 通知标签变更\n  private notifyChange = (tags: TagValue[]) => {\n    this.notify(tags);\n  };\n\n  // 处理清除按钮点击\n  private handleClear = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    const { onClearButtonClick = () => {} } = this.props;\n    onClearButtonClick(e);\n\n    const { tags } = this.state;\n    const nextTags = tags.filter((i) => i.attr && i.attr.removeable === false);\n    const index = `tag-${nextTags.length}`;\n\n    if (tags.length <= 0) {\n      this.tagRefs[index]?.setInputValue(\"\");\n      return;\n    }\n\n    this.setTags(nextTags, () => {\n      return setTimeout(() => {\n        this.tagRefs[index]?.setInputValue(\"\");\n        this.tagRefs[index]?.focusInput();\n      }, 0);\n    });\n\n    this.setState({\n      curPos: 0,\n      curPosType: FocusPosType.INPUT,\n    });\n\n    // 刷新下拉列表位置\n    const input = this.tagRefs[`tag-${tags.length}`];\n    if (input) {\n      input?.scheduleUpdate?.();\n    }\n  };\n\n  // 处理帮助按钮点击\n  private handleHelp = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    const { onHelpButtonClick = () => {} } = this.props;\n\n    if (onHelpButtonClick(e) === false) {\n      return;\n    }\n  };\n\n  // 处理搜索按钮点击\n  private handleSearch = (e: React.MouseEvent) => {\n    const { active, tags } = this.state;\n    const { onSearchButtonClick = () => {} } = this.props;\n\n    if (!active) {\n      // 如果监听了按钮点击，此时点击按钮不激活搜索框\n      if (\"onSearchButtonClick\" in this.props) {\n        e.stopPropagation();\n        onSearchButtonClick(e, this.getValue(tags));\n      }\n      return;\n    }\n\n    e.stopPropagation();\n\n    // 输入值生成标签操作会异步改变 tags\n    // 此处保证 tags 状态变化完成后再进行回调\n    setTimeout(() => {\n      onSearchButtonClick(e, this.getValue(tags));\n    }, 100);\n\n    let flag = false;\n\n    const input = this.tagRefs[`tag-${tags.length}`];\n    if (input && input.addTagByInputValue) {\n      if (input.addTagByInputValue()) {\n        flag = true;\n      }\n    }\n\n    for (let i = 0; i < tags.length; ++i) {\n      const tagInput = this.tagRefs[`tag-${i}`];\n      if (!tagInput || !tagInput.addTagByEditInputValue) return;\n\n      // @ts-ignore\n      if (tags[i][\"_edit\"] && tagInput.addTagByEditInputValue()) {\n        flag = true;\n      }\n    }\n\n    if (flag) return;\n\n    this.notify(tags);\n    input.focusInput();\n  };\n\n  // 处理标签事件\n  private handleTagEvent = async (\n    type: string,\n    index: number,\n    payload?: any\n  ) => {\n    const { tags } = this.state;\n    const newTags = clone(tags);\n\n    switch (type) {\n      case \"add\":\n        payload[\"_key\"] = COUNTER++;\n        newTags.splice(++index, 0, payload);\n        this.setTags(newTags, () => {\n          this.tagRefs[`tag-${index}`]?.focusInput();\n        });\n        this.setState({ showSelect: false });\n        break;\n\n      case \"edit\":\n        this.tagRefs[`tag-${index}`]?.editDone();\n        newTags[index].attr = payload.attr;\n        newTags[index].values = payload.values;\n        // @ts-ignore\n        newTags[index][\"_edit\"] = false;\n        this.setTags(newTags);\n        index++;\n        this.setState({\n          showSelect: false,\n          curPosType: FocusPosType.INPUT,\n        });\n        break;\n\n      case \"edit-cancel\":\n        this.tagRefs[`tag-${index}`]?.editDone();\n        this.setTags(newTags, () => null, false);\n        this.setState({\n          showSelect: false,\n          curPosType: FocusPosType.INPUT,\n        });\n        break;\n\n      case \"editing\":\n        if (\"attr\" in payload && newTags[index])\n          newTags[index].attr = payload.attr;\n        if (\"values\" in payload && newTags[index])\n          newTags[index].values = payload.values;\n        this.setTags(newTags, null, false);\n        break;\n\n      case \"del\":\n        if (payload === \"keyboard\") index--;\n        if (!newTags[index]) break;\n\n        const { onDeleteTag } = this.props;\n        const canDeleteTag = await onDeleteTag?.(newTags[index]);\n        if (onDeleteTag && !Boolean(canDeleteTag)) break;\n\n        const attr = newTags[index].attr;\n        if (attr && attr?.removeable === false) {\n          break;\n        }\n\n        newTags.splice(index, 1);\n        this.setTags(newTags, () => {\n          this.setState({ curPosType: FocusPosType.INPUT });\n        });\n\n        if (payload !== \"edit\") {\n          this.setState({ showSelect: false });\n        }\n        break;\n\n      case \"click\":\n        if (!this.state.active) {\n          this.open();\n          return;\n        }\n\n        const pos = payload;\n        // @ts-ignore\n        newTags[index][\"_edit\"] = true;\n        this.setTags(\n          newTags,\n          () => {\n            this.setState({ showSelect: true }, () => {\n              this.tagRefs[`tag-${index}`]?.edit(pos);\n            });\n          },\n          false\n        );\n        this.setState({ curPosType: FocusPosType.INPUT_EDIT });\n        break;\n\n      case \"click-input\":\n        if (payload === \"edit\") {\n          this.setState({ curPosType: FocusPosType.INPUT_EDIT });\n        } else {\n          this.setState({ curPosType: FocusPosType.INPUT });\n        }\n\n        if (!this.state.active) {\n          this.setState({ active: true });\n        }\n\n        this.setState({ showSelect: true });\n        break;\n    }\n\n    this.setState({ curPos: index });\n  };\n\n  render() {\n    const {\n      attributes = [],\n      hideHelp,\n      tips = 'Separate keywords with \"|\"; press Enter to separate filter tags',\n      attributesSelectTips = \"Select a filter\",\n      disableAttributesFilter,\n      disabled,\n      forwardRef,\n    } = this.props;\n\n    const { active, curPos, curPosType, showSelect, tags } = this.state;\n\n    // 用于计算 focused 及 isFocused, 判断是否显示选择组件\n    let focusedInputIndex = -1;\n    if (\n      curPosType === FocusPosType.INPUT ||\n      curPosType === FocusPosType.INPUT_EDIT\n    ) {\n      focusedInputIndex = curPos;\n    }\n\n    // 渲染标签列表\n    const tagList = tags.map((item, index) => {\n      // 补全 attr 属性\n      attributes.forEach((attrItem) => {\n        if (item.attr && attrItem.key && attrItem.key == item.attr.key) {\n          item.attr = Object.assign({}, item.attr, attrItem);\n        }\n      });\n\n      const selectedAttrKeys: string[] = [];\n      tags.forEach((tag) => {\n        if (\n          tag.attr &&\n          item.attr &&\n          // @ts-ignore\n          item[\"_edit\"] &&\n          item.attr.key === tag.attr.key\n        ) {\n          return null;\n        }\n        if (tag.attr && tag.attr.key && !tag.attr.reusable) {\n          selectedAttrKeys.push(tag.attr.key);\n        }\n      });\n\n      const useableAttributes = attributes.filter(\n        (item) => selectedAttrKeys.indexOf(item.key) < 0\n      );\n\n      return (\n        <Tag\n          ref={(tag) => (this.tagRefs[`tag-${index}`] = tag) as any}\n          active={active}\n          // @ts-ignore\n          key={item[\"_key\"]}\n          attributes={useableAttributes}\n          attr={item.attr}\n          values={item.values}\n          maxWidth={\n            this.searchWrapRef.current\n              ? this.searchWrapRef.current.clientWidth\n              : null\n          }\n          focused={\n            focusedInputIndex === index && showSelect ? curPosType : null\n          }\n          dispatchTagEvent={(type, payload) =>\n            this.handleTagEvent(type, index, payload)\n          }\n        />\n      );\n    });\n\n    // 过滤可用属性\n    const selectedAttrKeys = tags\n      .map((item) => (item.attr && !item.attr.reusable ? item.attr.key : null))\n      .filter((item) => !!item);\n\n    const useableAttributes = attributes.filter(\n      (item) => selectedAttrKeys.indexOf(item.key) < 0\n    );\n\n    // 添加输入标签\n    tagList.push(\n      <TagInput\n        key=\"__input__\"\n        ref={(input) => (this.tagRefs[`tag-${tags.length}`] = input) as any}\n        active={active}\n        maxWidth={\n          this.searchWrapRef.current\n            ? this.searchWrapRef.current.clientWidth\n            : null\n        }\n        attributes={useableAttributes}\n        isFocused={focusedInputIndex === tags.length && showSelect}\n        dispatchTagEvent={(type, payload) =>\n          this.handleTagEvent(type, tags.length, payload)\n        }\n      />\n    );\n\n    return (\n      <div className=\"w-full\">\n        <div\n          className={cn(\n            \"flex w-full flex-wrap gap-2\",\n            \"rounded-md border border-input\",\n            \"pl-2 py-0\",\n            \"bg-background text-sm\",\n            \"disabled:cursor-not-allowed disabled:opacity-50\",\n            !active && \"overflow-hidden\",\n            !disabled && [\n              \"cursor-text\",\n              active && \"border-primary\",\n              active && \"ring-4 ring-primary/20\",\n            ]\n          )}\n          ref={mergeRefs(this.searchWrapRef, forwardRef)}\n        >\n          <div\n            className={cn(\n              \"flex flex-1 flex-wrap gap-x-1.5 gap-y-1\",\n              \"items-center\"\n            )}\n            ref={mergeRefs(this.searchBoxRef)}\n            onClick={this.open}\n          >\n            <TagSearchBoxContext.Provider\n              value={{\n                attributesSelectTips,\n                disableAttributesFilter,\n                close: this.close,\n              }}\n            >\n              <React.Fragment>\n                {tagList}\n                <div\n                  className={cn(\n                    \"pointer-events-none text-muted-foreground/70 text-sm whitespace-nowrap flex items-center\"\n                  )}\n                >\n                  {tips}\n                </div>\n              </React.Fragment>\n            </TagSearchBoxContext.Provider>\n          </div>\n\n          <div className={cn(\"flex items-center gap-0.5\", \"bg-background\")}>\n            {!!active && tags.length > 0 && (\n              <TooltipProvider>\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"h-[30px] w-[30px] p-0 hover:bg-muted rounded-none\"\n                      onClick={this.handleClear}\n                    >\n                      <X className=\"h-4 w-4\" />\n                      <span className=\"sr-only\">Clear</span>\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent side=\"bottom\" className=\"text-xs\">\n                    Clear all tags\n                  </TooltipContent>\n                </Tooltip>\n              </TooltipProvider>\n            )}\n\n            {!!active && !hideHelp && (\n              <TooltipProvider>\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"h-[30px] w-[30px] p-0 hover:bg-muted rounded-none\"\n                      onClick={this.handleHelp}\n                    >\n                      <Info className=\"h-4 w-4\" />\n                      <span className=\"sr-only\">Help</span>\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent side=\"bottom\" className=\"text-xs\">\n                    Show help\n                  </TooltipContent>\n                </Tooltip>\n              </TooltipProvider>\n            )}\n\n            <TooltipProvider>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    className={cn(\n                      \"h-[30px] w-[30px] p-0 hover:bg-muted rounded-none rounded-r-md\",\n                      active && \"text-primary\"\n                    )}\n                    disabled={disabled}\n                    onClick={this.handleSearch}\n                  >\n                    <Search className=\"h-4 w-4\" />\n                    <span className=\"sr-only\">Search</span>\n                  </Button>\n                </TooltipTrigger>\n                {active && (\n                  <TooltipContent side=\"bottom\" className=\"text-xs\">\n                    Search\n                  </TooltipContent>\n                )}\n              </Tooltip>\n            </TooltipProvider>\n          </div>\n        </div>\n\n        <Dialog>\n          <DialogContent className=\"max-w-[600px]\">\n            <DialogHeader>\n              <DialogTitle className=\"text-base\">Help</DialogTitle>\n            </DialogHeader>\n            {/* <TagSearchBoxHelp /> */}\n          </DialogContent>\n        </Dialog>\n      </div>\n    );\n  }\n}\n\nexport const TagSearchBoxWithOutsideClick = withOutsideClick(\"close\")(\n  ITagSearchBox,\n  {\n    ignoreClasses: [\"ignore-outside-click\"],\n  }\n);\n\nexport const TagSearchBox = forwardRef<HTMLDivElement, TagSearchBoxProps>(\n  (props, ref) => {\n    return <TagSearchBoxWithOutsideClick {...props} forwardRef={ref} />;\n  }\n);\n\nTagSearchBox.displayName = \"TagSearchBox\";\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/TagSearchBox.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/TagInput.tsx",
      "content": "import React, { Component, createRef } from \"react\";\nimport {\n  AttributeSelect,\n  AttributeValue,\n} from \"@/registry/new-york/tag-search-box/AttributeSelect.tsx\";\nimport { ValueSelect } from \"@/registry/new-york/tag-search-box/valueselect/ValueSelect.tsx\";\nimport { TagSearchBoxContext } from \"@/registry/new-york/tag-search-box/TagSearchboxContext.ts\";\nimport { cn } from \"@/lib/utils\";\n\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\n\nconst keys: Record<string | number, string> = {\n  8: \"backspace\",\n  9: \"tab\",\n  13: \"enter\",\n  27: \"esc\",\n  37: \"left\",\n  38: \"up\",\n  39: \"right\",\n  40: \"down\",\n};\n\nconst INPUT_MIN_SIZE = 0;\nconst SELECT_MIN_HEIGHT = 242;\n\ninterface TagInputProps {\n  /**\n   * 触发标签相关事件\n   */\n  dispatchTagEvent: (type: string, payload?: any) => void;\n  /**\n   * 所有属性集合\n   */\n  attributes: Array<AttributeValue>;\n  /**\n   * 是否为 Focus 态\n   */\n  isFocused: boolean;\n  /**\n   * 搜索框是否处于展开状态\n   */\n  active: boolean;\n  /**\n   * 输入框类型（用于修改标签值的 Input type 为 \"edit\"）\n   */\n  type?: \"edit\" | \"add\";\n  /**\n   * 是否隐藏\n   */\n  hidden?: boolean;\n  /**\n   * 最大宽度\n   */\n  maxWidth: number | null;\n  /**\n   * 处理按键事件\n   */\n  handleKeyDown?: (e: any) => void;\n  /**\n   * 位置偏移\n   */\n  inputOffset?: number;\n}\n\ninterface TagInputState {\n  inputWidth: number;\n  inputValue: string;\n  fullInputValue: string;\n  attribute: AttributeValue | null;\n  values: any[];\n  showAttrSelect: boolean;\n  showValueSelect: boolean;\n  valueSelectOffset: number;\n}\n\nclass TagInput extends Component<TagInputProps, TagInputState> {\n  static contextType = TagSearchBoxContext;\n  declare context: React.ContextType<typeof TagSearchBoxContext>;\n\n  private wrapperRef = createRef<HTMLDivElement>();\n  private inputRef = createRef<HTMLInputElement & HTMLTextAreaElement>();\n  private inputMirrorRef = createRef<HTMLSpanElement>();\n  private attrSelectRef = createRef<any>();\n  private valueSelectRef = createRef<any>();\n\n  constructor(props: TagInputProps) {\n    super(props);\n    this.state = {\n      inputWidth: INPUT_MIN_SIZE,\n      inputValue: \"\",\n      fullInputValue: \"\",\n      attribute: null,\n      values: [],\n      showAttrSelect: false,\n      showValueSelect: false,\n      valueSelectOffset: 0,\n    };\n  }\n\n  // Helper function to get attribute string and value string\n  private getAttrStrAndValueStr = (str: string) => {\n    let attrStr = str,\n      valueStr = \"\",\n      pos = -1;\n\n    for (let i = 0; i < this.props.attributes.length; ++i) {\n      if (str.indexOf(this.props.attributes[i].name + \":\") === 0) {\n        attrStr = this.props.attributes[i].name;\n        valueStr = str.substr(attrStr.length + 1);\n        pos = this.props.attributes[i].name.length;\n      }\n    }\n\n    return { attrStr, valueStr, pos };\n  };\n\n  // Refresh selection component display\n  private refreshShow = () => {\n    const { inputValue, attribute } = this.state;\n    const input = this.inputRef.current;\n    const start = input?.selectionStart ?? 0;\n    const end = input?.selectionEnd ?? 0;\n    const pos = this.getAttrStrAndValueStr(inputValue).pos;\n\n    if (pos < 0 || start <= pos) {\n      this.setState({\n        showAttrSelect: true,\n        showValueSelect: false,\n      });\n      return;\n    }\n\n    if (attribute && end > pos) {\n      this.setState({\n        showAttrSelect: false,\n        showValueSelect: true,\n      });\n    }\n  };\n\n  // Focus input\n  public focusInput = () => {\n    if (!this.inputRef.current) return;\n    this.inputRef.current.focus();\n  };\n\n  // Move cursor to end\n  public moveToEnd = () => {\n    const input = this.inputRef.current;\n    input?.focus();\n    const value = this.state.inputValue;\n\n    setTimeout(() => input?.setSelectionRange(value.length, value.length), 0);\n  };\n\n  // Select value part\n  public selectValue = () => {\n    const input = this.inputRef.current;\n    input?.focus();\n    const value = this.state.inputValue;\n\n    let pos = this.getAttrStrAndValueStr(value).pos;\n    if (pos < 0) pos = -2;\n\n    setTimeout(() => {\n      input?.setSelectionRange(pos + 2, value.length);\n      this.refreshShow();\n    }, 0);\n  };\n\n  // Select attribute part\n  public selectAttr = () => {\n    const input = this.inputRef.current;\n    input?.focus();\n    const value = this.state.inputValue;\n    let pos = this.getAttrStrAndValueStr(value).pos;\n    if (pos < 0) pos = 0;\n\n    setTimeout(() => {\n      input?.setSelectionRange(0, pos);\n      this.refreshShow();\n    }, 0);\n  };\n\n  // Set input value\n  public setInputValue = (value: string, callback?: () => void) => {\n    if (this.props.type === \"edit\" && value.trim().length <= 0) {\n      return this.props.dispatchTagEvent(\"del\", \"edit\");\n    }\n\n    let attribute = null,\n      valueStr = value;\n    const mirror = this.inputMirrorRef.current;\n\n    // Check if attribute exists\n    for (let i = 0; i < this.props.attributes.length; ++i) {\n      if (\n        value.indexOf(this.props.attributes[i].name + \":\") === 0 ||\n        value.indexOf(this.props.attributes[i].name + \"：\") === 0\n      ) {\n        attribute = this.props.attributes[i];\n        valueStr = value.substr(this.props.attributes[i].name.length + 1);\n\n        if (mirror) {\n          mirror.innerText = attribute.name + \": \";\n          let width = mirror.clientWidth;\n          if (this.props.inputOffset) width += this.props.inputOffset;\n          this.setState({ valueSelectOffset: width });\n        }\n        break;\n      }\n    }\n\n    // Handle leading spaces\n    if (attribute && valueStr.replace(/^\\s+/, \"\").length > 0) {\n      value = attribute.name + \": \" + valueStr.replace(/^\\s+/, \"\");\n    } else if (attribute) {\n      value = attribute.name + \":\" + valueStr;\n    }\n\n    if (attribute !== this.state.attribute) {\n      this.setState({\n        values: valueStr.split(\"|\").map((item) => ({ name: item.trim() })),\n      });\n    }\n    this.setState({ attribute }, this.refreshShow);\n\n    if (this.props.type === \"edit\") {\n      this.props.dispatchTagEvent(\"editing\", { attr: attribute });\n    }\n\n    mirror!.innerText = value;\n    const width = Math.max(mirror!.clientWidth, INPUT_MIN_SIZE);\n    this.setState(\n      {\n        inputValue: value,\n        fullInputValue: value,\n        inputWidth: width,\n      },\n      () => {\n        callback && callback();\n      }\n    );\n  };\n\n  // Set full input value (including IME process)\n  private setFullInputValue = (value: string) => {\n    let attribute = null,\n      valueStr = value;\n    const mirror = this.inputMirrorRef.current;\n\n    for (let i = 0; i < this.props.attributes.length; ++i) {\n      if (\n        value.indexOf(this.props.attributes[i].name + \":\") === 0 ||\n        value.indexOf(this.props.attributes[i].name + \"：\") === 0\n      ) {\n        attribute = this.props.attributes[i];\n        valueStr = value.substr(this.props.attributes[i].name.length + 1);\n\n        if (mirror) {\n          mirror.innerText = attribute.name + \": \";\n          let width = mirror.clientWidth;\n          if (this.props.inputOffset) width += this.props.inputOffset;\n          this.setState({ valueSelectOffset: width });\n        }\n        break;\n      }\n    }\n\n    if (attribute && valueStr.replace(/^\\s+/, \"\").length > 0) {\n      value = attribute.name + \": \" + valueStr.replace(/^\\s+/, \"\");\n    } else if (attribute) {\n      value = attribute.name + \":\" + valueStr;\n    }\n\n    if (mirror) {\n      mirror.innerText = value;\n      const width = Math.max(mirror.clientWidth, INPUT_MIN_SIZE);\n      this.setState({\n        fullInputValue: value,\n        inputWidth: width,\n      });\n    }\n  };\n\n  // Reset input\n  public resetInput = (callback?: () => void) => {\n    this.setInputValue(\"\", callback);\n    this.setState({ inputWidth: INPUT_MIN_SIZE });\n  };\n\n  // Get input value\n  public getInputValue = () => {\n    return this.state.inputValue;\n  };\n\n  // Add tag by input value\n  public addTagByInputValue = () => {\n    const { attribute, values, inputValue } = this.state;\n    const type = this.props.type || \"add\";\n\n    if (\n      attribute &&\n      this.props.attributes.filter((item) => item.key === attribute.key)\n        .length > 0\n    ) {\n      if (values.length <= 0) {\n        return false;\n      }\n      this.props.dispatchTagEvent(type, { attr: attribute, values });\n    } else {\n      if (inputValue.trim().length <= 0) {\n        return false;\n      }\n      const list = inputValue\n        .split(\"|\")\n        .filter((item) => item.trim().length > 0)\n        .map((item) => ({ name: item.trim() }));\n      this.props.dispatchTagEvent(type, { attr: null, values: list });\n    }\n\n    this.setState({\n      showAttrSelect: false,\n      showValueSelect: false,\n    });\n\n    if (this.props.type !== \"edit\") {\n      this.resetInput();\n    }\n    return true;\n  };\n\n  // Event handlers\n  private handleInputChange = (\n    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n  ) => {\n    this.setInputValue(e.target.value);\n  };\n\n  private handleInputClick = (e: React.MouseEvent) => {\n    this.props.dispatchTagEvent(\"click-input\", this.props.type);\n    e.stopPropagation();\n    this.focusInput();\n  };\n\n  private handleAttrSelect = (attr: any) => {\n    if (attr && attr.key) {\n      const str = attr.name + \": \";\n      const { inputValue } = this.state;\n\n      if (inputValue.indexOf(str) >= 0) {\n        this.selectValue();\n      } else {\n        this.setInputValue(str);\n      }\n      this.setState({ values: [] });\n    }\n    this.focusInput();\n  };\n\n  private handleValueChange = (values: any[]) => {\n    this.setState({ values });\n    this.setInputValue(\n      (this.state.attribute?.name ?? \"\") +\n        \": \" +\n        values.map((item) => item.name).join(\" | \")\n    );\n    this.focusInput();\n  };\n\n  private handleValueSelect = (values: any[]) => {\n    this.setState({ values });\n\n    if (values.length <= 0) {\n      this.setInputValue((this.state.attribute?.name ?? \"\") + \": \");\n      return;\n    }\n\n    if (values.length > 0 && this.state.attribute) {\n      const key = this.state.attribute.key;\n      if (this.props.attributes.filter((item) => item.key === key).length > 0) {\n        const type = this.props.type || \"add\";\n        this.props.dispatchTagEvent(type, {\n          attr: this.state.attribute,\n          values,\n        });\n      }\n      this.focusInput();\n    }\n\n    if (this.props.type !== \"edit\") {\n      this.resetInput();\n    }\n  };\n\n  private handleValueCancel = () => {\n    if (this.props.type === \"edit\") {\n      const { attribute, values } = this.state;\n      this.props.dispatchTagEvent(\"edit-cancel\", {\n        attr: attribute,\n        values,\n      });\n    } else {\n      this.resetInput(() => {\n        this.focusInput();\n      });\n    }\n  };\n\n  private handlePaste = (e: React.ClipboardEvent) => {\n    e.stopPropagation();\n    e.preventDefault();\n\n    const { attribute } = this.state;\n\n    if (!attribute || attribute.type === \"input\") {\n      let value = \"\";\n\n      try {\n        const clipboardData = e.clipboardData;\n        value = clipboardData.getData(\"Text\") || \"\";\n      } catch (_) {}\n\n      if (/^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/.test(value)) {\n        value = value.replace(/[\\r\\n\\t,，\\s]+/g, \"|\");\n      } else {\n        value = value.replace(/[\\r\\n\\t,，]+/g, \"|\");\n      }\n\n      value = value\n        .split(\"|\")\n        .map((item) => item.trim())\n        .filter((item) => item.length > 0)\n        .join(\" | \");\n\n      const input = this.inputRef.current;\n      const start = input?.selectionStart;\n      const end = input?.selectionEnd;\n      const { inputValue } = this.state;\n\n      const curValue =\n        inputValue.substring(0, start!) +\n        value +\n        inputValue.substring(end!, inputValue.length);\n\n      if (attribute && attribute.type === \"input\") {\n        this.setInputValue(curValue, this.focusInput);\n        return;\n      }\n\n      if (inputValue.length > 0) {\n        this.setInputValue(curValue, this.focusInput);\n      } else {\n        this.setInputValue(curValue, this.addTagByInputValue);\n      }\n    }\n  };\n\n  private handleKeyDown = (e: React.KeyboardEvent) => {\n    if (!keys[e.keyCode]) return;\n\n    if (this.props.hidden) {\n      return this.props.handleKeyDown?.(e);\n    }\n\n    const { inputValue } = this.state;\n\n    if (keys[e.keyCode] === \"backspace\" && inputValue.length > 0) return;\n\n    if (\n      (keys[e.keyCode] === \"left\" || keys[e.keyCode] === \"right\") &&\n      inputValue.length > 0\n    ) {\n      setTimeout(this.refreshShow, 0);\n      return;\n    }\n\n    if (keys[e.keyCode] === \"esc\") {\n      if (!inputValue) {\n        this.context.close?.();\n      }\n      return this.handleValueCancel();\n    }\n\n    e.preventDefault();\n\n    if (this.attrSelectRef.current) {\n      if (this.attrSelectRef.current.handleKeyDown(e.keyCode) === false) return;\n    }\n\n    if (this.valueSelectRef.current) {\n      this.valueSelectRef.current.handleKeyDownForRenderMode(e.key);\n      if (this.valueSelectRef.current.handleKeyDown(e.keyCode) === false)\n        return;\n    }\n\n    switch (keys[e.keyCode]) {\n      case \"enter\":\n      case \"tab\":\n        if (!this.props.isFocused) {\n          this.props.dispatchTagEvent(\"click-input\");\n        }\n        this.addTagByInputValue();\n        break;\n      case \"backspace\":\n        this.props.dispatchTagEvent(\"del\", \"keyboard\");\n        break;\n      case \"up\":\n      case \"down\":\n        break;\n    }\n  };\n\n  public setInfo = (info: any, callback?: () => void) => {\n    const attribute = info.attr;\n    const values = info.values || [];\n\n    this.setState({ attribute, values }, () => {\n      if (attribute) {\n        const valueStr = values.map((item: any) => item.name).join(\" | \");\n        this.setInputValue(attribute.name + \": \" + valueStr, callback);\n      } else {\n        const valueStr = values.map((item: any) => item.name).join(\" | \");\n        this.setInputValue(valueStr, callback);\n      }\n    });\n  };\n\n  render() {\n    const { active, hidden, maxWidth, type, isFocused, attributes } =\n      this.props;\n\n    const {\n      inputWidth,\n      inputValue,\n      fullInputValue,\n      showAttrSelect,\n      showValueSelect,\n      attribute,\n      valueSelectOffset,\n    } = this.state;\n    const { valueStr, attrStr } = this.getAttrStrAndValueStr(inputValue);\n\n    let maxHeight = SELECT_MIN_HEIGHT;\n    try {\n      if (this.wrapperRef.current) {\n        maxHeight = Math.max(\n          window.innerHeight -\n            this.wrapperRef.current.getBoundingClientRect().bottom -\n            60,\n          SELECT_MIN_HEIGHT\n        );\n      }\n    } catch (_) {}\n\n    const isOpen =\n      active &&\n      isFocused &&\n      (showAttrSelect || (showValueSelect && !!attribute && !!attribute.type));\n\n    return (\n      <div\n        ref={this.wrapperRef}\n        className={cn(\n          \"relative inline-flex items-center\",\n          \"rounded-md\",\n          hidden && \"hidden\",\n          type === \"edit\" && !hidden && \"px-1\"\n        )}\n        style={{\n          width: hidden ? 0 : active ? inputWidth + 6 : 6,\n        }}\n        onClick={this.handleInputClick}\n      >\n        <Popover open={isOpen}>\n          <PopoverTrigger asChild>\n            <div\n              className={cn(\"relative flex items-center\")}\n              style={{\n                width: hidden ? 0 : inputWidth + 6,\n                maxWidth: maxWidth ? maxWidth - 36 : 435,\n              }}\n            >\n              {type !== \"edit\" ? (\n                <Input\n                  ref={this.inputRef as React.RefObject<HTMLInputElement>}\n                  value={inputValue}\n                  onChange={this.handleInputChange}\n                  onKeyDown={this.handleKeyDown}\n                  onClick={this.refreshShow}\n                  onPaste={this.handlePaste}\n                  onFocus={this.refreshShow}\n                  onInput={(e) => this.setFullInputValue(e.currentTarget.value)}\n                  className={cn(\n                    \"w-full border-none p-0 text-sm\",\n                    \"bg-transparent\",\n                    \"focus:outline-none focus:ring-0 focus-visible:ring-0\",\n                    \"placeholder:text-muted-foreground/70\",\n                    \"caret-foreground\",\n                    \"shadow-none\",\n                    \"flex items-center\",\n                    \"resize-none\",\n                    \"h-7\"\n                  )}\n                  type=\"text\"\n                  style={{\n                    width: hidden ? 0 : inputWidth + 6,\n                    maxWidth: maxWidth ? maxWidth - 36 : 435,\n                  }}\n                  data-type=\"tag-input\"\n                />\n              ) : (\n                <React.Fragment>\n                  <pre style={{ display: \"block\", visibility: \"hidden\" }}>\n                    <div\n                      className=\"text-sm\"\n                      style={{\n                        width: hidden ? 0 : inputWidth + 36,\n                        maxWidth: maxWidth ? maxWidth - 36 : 435,\n                        whiteSpace: \"normal\",\n                      }}\n                    >\n                      {fullInputValue}\n                    </div>\n                  </pre>\n                  <Textarea\n                    ref={this.inputRef as React.RefObject<HTMLTextAreaElement>}\n                    value={inputValue}\n                    onChange={this.handleInputChange}\n                    onKeyDown={this.handleKeyDown}\n                    onClick={this.refreshShow}\n                    onPaste={this.handlePaste}\n                    onFocus={this.refreshShow}\n                    className={cn(\n                      \"w-full border-none p-0 text-sm min-h-none\",\n                      \"bg-transparent\",\n                      \"focus:outline-none focus:ring-0 focus-visible:ring-0\",\n                      \"placeholder:text-muted-foreground/70\",\n                      \"caret-foreground\",\n                      \"shadow-none\",\n                      \"resize-none\",\n                      \"h-8\"\n                    )}\n                    style={{\n                      width: hidden ? 0 : inputWidth + 30,\n                      maxWidth: maxWidth ? maxWidth - 36 : 435,\n                      position: \"absolute\",\n                      top: 0,\n                      left: 0,\n                      resize: \"none\",\n                      overflow: \"hidden\",\n                    }}\n                  />\n                </React.Fragment>\n              )}\n              <span\n                ref={this.inputMirrorRef}\n                className=\"invisible absolute whitespace-pre text-sm\"\n                style={{\n                  pointerEvents: \"none\",\n                  zIndex: -1,\n                }}\n              >\n                {fullInputValue}\n              </span>\n            </div>\n          </PopoverTrigger>\n          <PopoverContent\n            className={cn(\n              \"w-[--radix-popover-trigger-width] p-0\",\n              \"rounded-md border bg-popover text-popover-foreground shadow-md\",\n              \"ignore-outside-click\"\n            )}\n            align=\"start\"\n            sideOffset={8}\n            alignOffset={valueSelectOffset}\n            onOpenAutoFocus={(e) => {\n              e.preventDefault();\n            }}\n          >\n            {showAttrSelect && (\n              <AttributeSelect\n                ref={this.attrSelectRef}\n                attributes={attributes}\n                inputValue={attrStr}\n                maxHeight={maxHeight}\n                onSelect={this.handleAttrSelect}\n              />\n            )}\n            {showValueSelect && !!attribute && !!attribute.type && (\n              <ValueSelect\n                ref={this.valueSelectRef}\n                type={attribute.type}\n                values={attribute.values ?? []}\n                render={attribute.render}\n                inputValue={valueStr.trim()}\n                offset={this.state.valueSelectOffset}\n                onChange={this.handleValueChange}\n                onSelect={this.handleValueSelect}\n                onCancel={this.handleValueCancel}\n                maxHeight={maxHeight}\n              />\n            )}\n          </PopoverContent>\n        </Popover>\n      </div>\n    );\n  }\n}\n\nexport { TagInput };\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/TagInput.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/Tag.tsx",
      "content": "import React, { Component, createRef } from \"react\";\nimport { TagInput } from \"@/registry/new-york/tag-search-box/TagInput\";\nimport { FocusPosType } from \"@/registry/new-york/tag-search-box/TagSearchBox\";\nimport { X } from \"lucide-react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Value,\n  AttributeValue,\n} from \"@/registry/new-york/tag-search-box/AttributeSelect\";\n\nexport interface TagValue {\n  /**\n   * 标签属性\n   */\n  attr?: AttributeValue;\n  /**\n   * 标签属性值\n   */\n  values?: Value[];\n}\n\ninterface TagProps {\n  /**\n   * 标签属性\n   */\n  attr?: AttributeValue;\n  /**\n   * 标签属性值\n   */\n  values?: Value[];\n  /**\n   * 触发标签相关事件\n   */\n  dispatchTagEvent?: (type: string, payload?: any) => void;\n  /**\n   * 所有属性集合\n   */\n  attributes: AttributeValue[];\n  /**\n   * 当前聚焦状态\n   */\n  focused: FocusPosType | null;\n  /**\n   * 最大长度\n   */\n  maxWidth?: number | null;\n  /**\n   * 搜索框是否处于展开状态\n   */\n  active: boolean;\n}\n\ninterface TagRef {\n  focusTag: () => void;\n  focusInput: () => void;\n  resetInput: () => void;\n  setInputValue: (value: string, callback?: () => void) => void;\n  getInputValue: () => string | undefined;\n  addTagByInputValue: () => boolean | undefined;\n  addTagByEditInputValue: () => boolean | undefined;\n  setInfo: (info: any, callback?: () => void) => void;\n  moveToEnd: () => void;\n  getInfo: any;\n  edit: (pos: string) => void;\n  editDone: () => void;\n}\n\nconst keys: Record<string, string> = {\n  \"8\": \"backspace\",\n  \"13\": \"enter\",\n  \"37\": \"left\",\n  \"38\": \"up\",\n  \"39\": \"right\",\n  \"40\": \"down\",\n};\n\nexport class Tag\n  extends Component<TagProps, { inEditing: boolean }>\n  implements TagRef\n{\n  private contentRef = createRef<HTMLDivElement>();\n  private inputInsideRef: any = null;\n  private inputRef: any = null;\n\n  constructor(props: TagProps) {\n    super(props);\n    this.state = {\n      inEditing: false,\n    };\n  }\n\n  handleTagClick = (e: React.MouseEvent, pos?: string) => {\n    e.stopPropagation();\n    this.props.dispatchTagEvent?.(\"click\", pos);\n  };\n\n  handleDelete = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    this.props.dispatchTagEvent?.(\"del\");\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if (!keys[e.keyCode]) return;\n\n    e.preventDefault();\n\n    switch (keys[e.keyCode]) {\n      case \"tab\":\n      case \"enter\":\n        this.props.dispatchTagEvent?.(\"click\", \"value\");\n        break;\n      case \"backspace\":\n        this.props.dispatchTagEvent?.(\"del\", \"keyboard\");\n        break;\n    }\n  };\n\n  focusTag = () => {\n    this.inputInsideRef?.focusInput();\n  };\n\n  focusInput = () => {\n    this.inputRef?.focusInput();\n  };\n\n  resetInput = () => {\n    this.inputInsideRef?.resetInput();\n  };\n\n  setInputValue = (value: string, callback?: () => void) => {\n    this.inputRef?.setInputValue(value, callback);\n  };\n\n  getInputValue = () => {\n    return this.inputRef?.getInputValue();\n  };\n\n  addTagByInputValue = () => {\n    return this.inputRef?.addTagByInputValue();\n  };\n\n  addTagByEditInputValue = () => {\n    if (!this.inputInsideRef) return;\n    return this.inputInsideRef?.addTagByInputValue();\n  };\n\n  setInfo = (info: any, callback?: () => void) => {\n    return this.inputRef?.setInfo(info, callback);\n  };\n\n  moveToEnd = () => {\n    return this.inputRef?.moveToEnd();\n  };\n\n  getInfo = () => {\n    const { attr, values } = this.props;\n    const info = { attr, values };\n    return info;\n  };\n\n  edit = (pos: string) => {\n    this.setState({ inEditing: true });\n    const input = this.inputInsideRef;\n    input?.setInfo(this.getInfo(), () => {\n      if (pos === \"attr\") {\n        return input.selectAttr();\n      }\n      return input.selectValue();\n    });\n  };\n\n  editDone = () => {\n    this.setState({ inEditing: false });\n  };\n\n  render() {\n    const {\n      attr,\n      values,\n      dispatchTagEvent,\n      attributes,\n      focused,\n      maxWidth,\n      active,\n    } = this.props;\n    const { inEditing } = this.state;\n\n    const formattedAttrStr = attr && attr.name ? `${attr.name}: ` : \"\";\n    const valueStr = (values || []).map((item) => item.name).join(\" | \");\n    const removeable = attr && \"removeable\" in attr ? attr.removeable : true;\n\n    return (\n      <div\n        onClick={(e) => this.handleTagClick(e)}\n        tabIndex={0}\n        role=\"button\"\n        ref={this.contentRef}\n      >\n        <div\n          className={cn(\n            \"group relative inline-flex items-center gap-1\",\n            \"rounded-md border border-input bg-background px-2 py-1\",\n            \"text-sm transition-colors\",\n            \"hover:bg-accent hover:text-accent-foreground\",\n            \"cursor-text\",\n            \"focus:outline-none focus:ring-1 focus:ring-ring focus:ring-offset-1\"\n          )}\n          style={{\n            display: inEditing ? \"none\" : undefined,\n          }}\n        >\n          {attr && (\n            <span\n              className=\"text-muted-foreground/80 text-xs\"\n              onClick={(e) => {\n                e.stopPropagation();\n                this.handleTagClick(e, \"attr\");\n              }}\n            >\n              {formattedAttrStr}\n            </span>\n          )}\n          <span\n            className=\"font-medium text-xs\"\n            onClick={(e) => {\n              e.stopPropagation();\n              this.handleTagClick(e, \"value\");\n            }}\n          >\n            {valueStr}\n          </span>\n          {removeable && (\n            <TooltipProvider>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <button\n                    className={cn(\n                      \"ml-1 rounded-sm opacity-70 ring-offset-background\",\n                      \"transition-opacity hover:opacity-100\",\n                      \"focus:outline-none focus:ring-1 focus:ring-ring focus:ring-offset-1\",\n                      \"disabled:pointer-events-none disabled:opacity-50\"\n                    )}\n                    onClick={this.handleDelete}\n                    disabled={!active}\n                  >\n                    <X className=\"h-3 w-3\" />\n                    <span className=\"sr-only\">Remove tag</span>\n                  </button>\n                </TooltipTrigger>\n                {active && (\n                  <TooltipContent side=\"bottom\" className=\"text-xs\">\n                    <p>Click to remove tag</p>\n                  </TooltipContent>\n                )}\n              </Tooltip>\n            </TooltipProvider>\n          )}\n        </div>\n\n        {active && (\n          <TooltipProvider>\n            <Tooltip>\n              <TooltipContent side=\"bottom\" className=\"text-xs\">\n                <p>Click to modify. Press Enter to finish.</p>\n              </TooltipContent>\n            </Tooltip>\n          </TooltipProvider>\n        )}\n\n        <TagInput\n          type=\"edit\"\n          hidden={!inEditing}\n          maxWidth={maxWidth!}\n          handleKeyDown={this.handleKeyDown}\n          active={active}\n          ref={(input) => (this.inputInsideRef = input) as any}\n          attributes={attributes}\n          dispatchTagEvent={dispatchTagEvent!}\n          isFocused={focused === FocusPosType.INPUT_EDIT}\n        />\n      </div>\n    );\n  }\n}\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/Tag.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/AttributeSelect.tsx",
      "content": "import React, { Component } from \"react\";\nimport { DropdownMenu } from \"@/components/ui/dropdown-menu\";\nimport { CommandItem, Command, CommandGroup } from \"@/components/ui/command\";\nimport { TagSearchBoxContext } from \"@/registry/new-york/tag-search-box/TagSearchboxContext\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface Value {\n  /**\n   * 项标识\n   */\n  key?: string;\n  /**\n   * 属性展示值\n   */\n  name: string;\n  /**\n   * 项渲染样式\n   */\n  style?: React.CSSProperties;\n}\nexport interface AttributeRenderProps {\n  /**\n   * 当前输入值\n   */\n  inputValue: string;\n  /**\n   * 监听某些操作键位被按下\n   */\n  onOperationalKeyDown?: (\n    listener: (key: \"ArrowDown\" | \"ArrowUp\" | \"Enter\" | \"Tab\") => void\n  ) => void;\n  /**\n   * 确认选择\n   */\n  onSelect: (value: Value[]) => void;\n  /**\n   * 取消\n   */\n  onCancel: () => void;\n}\nexport type AttributeType = \"input\" | \"single\" | \"multiple\" | \"render\";\nexport type AttributeTypeOptions =\n  | [\"input\", {}]\n  | [\"render\", {}]\n  | [\n      \"single\",\n      {\n        /**\n         * 是否启用搜索\n         * @default false\n         * @since 2.5.0\n         */\n        searchable?: boolean;\n        /**\n         * 无可选项时提示内容\n         */\n        emptyText?: React.ReactNode;\n        /**\n         * 列表最大宽度\n         * @since 2.7.9\n         */\n        maxWidth?: number | string;\n        /**\n         * 自定义渲染项\n         * @since 2.7.9\n         */\n        itemRender?: (text: string, value: Value) => React.ReactNode;\n      }\n    ]\n  | [\n      \"multiple\",\n      {\n        /**\n         * 是否开启全选\n         * @default true\n         */\n        all?: boolean;\n        /**\n         * 是否启用搜索\n         * @default false\n         * @since 2.5.0\n         */\n        searchable?: boolean;\n        /**\n         * 无可选项时提示内容\n         */\n        emptyText?: React.ReactNode;\n        /**\n         * 列表最大宽度\n         * @since 2.7.9\n         */\n        maxWidth?: number | string;\n        /**\n         * 自定义渲染项\n         * @since 2.7.9\n         */\n        itemRender?: (text: string, value: Value) => React.ReactNode;\n      }\n    ];\nexport interface AttributeValue {\n  /**\n   * 为资源属性需求值的类型\n   *\n   * 可使用数组形式进行详细配置，如：\n   *\n   * ```js\n   * [\"multiple\", { all: true }]\n   * ```\n   *\n   * 其中：\n   *\n   *`\"single\"`：\n   *  - `searchable` 是否启用搜索\n   *  - `emptyText` 无可选项时提示内容\n   *  - `maxWidth` 列表最大宽度\n   *  - `itemRender` 自定义渲染列表项\n   *\n   *`\"multiple\"`：\n   *  - `all` 是否启用全选\n   *  - `searchable` 是否启用搜索\n   *  - `emptyText` 无可选项时提示内容\n   *  - `maxWidth` 列表最大宽度\n   *  - `itemRender` 自定义渲染列表项\n   *\n   * @docType \"input\" | \"single\" | \"multiple\" | \"render\" | [AttributeType, AttributeOptions]\n   */\n  type: AttributeType | AttributeTypeOptions;\n  /**\n   * 属性的唯一标识，会在结果中返回\n   */\n  key: string;\n  /**\n   * 资源属性值名称\n   */\n  name: string;\n  /**\n   * 资源属性可用值\n   * @docType Value[] | (() => Value[]) | (() => Promise<Value[]>)\n   */\n  values?: Value[] | (() => Value[]) | (() => Promise<Value[]>);\n  /**\n   * 该属性是否可重复选择\n   * @default false\n   */\n  reusable?: boolean;\n  /**\n   * 该属性是否可移除\n   * @default true\n   */\n  removeable?: boolean;\n  /**\n   * 自定义渲染\n   */\n  render?: (props: AttributeRenderProps) => React.ReactNode;\n}\nexport interface AttributeSelectProps {\n  attributes: AttributeValue[];\n  inputValue: string;\n  onSelect?: (attribute: AttributeValue) => void;\n  maxHeight: number;\n}\nexport interface AttributeSelectState {\n  select: number;\n  lastInputValue: string;\n}\n\nconst keys: Record<\n  string,\n  \"backspace\" | \"tab\" | \"enter\" | \"left\" | \"up\" | \"right\" | \"down\"\n> = {\n  \"8\": \"backspace\",\n  \"9\": \"tab\",\n  \"13\": \"enter\",\n  \"37\": \"left\",\n  \"38\": \"up\",\n  \"39\": \"right\",\n  \"40\": \"down\",\n};\n\nexport class AttributeSelect extends Component<\n  AttributeSelectProps,\n  AttributeSelectState\n> {\n  static contextType = TagSearchBoxContext;\n  declare context: React.ContextType<typeof TagSearchBoxContext>;\n\n  constructor(props: AttributeSelectProps) {\n    super(props);\n    this.state = {\n      select: -1,\n      lastInputValue: props.inputValue,\n    };\n  }\n\n  static getDerivedStateFromProps(\n    props: AttributeSelectProps,\n    state: AttributeSelectState\n  ) {\n    if (state.lastInputValue !== props.inputValue) {\n      return { select: -1, lastInputValue: props.inputValue };\n    }\n    return null;\n  }\n\n  getUseableList() {\n    const { attributes, inputValue } = this.props;\n    const { disableAttributesFilter } = this.context;\n\n    if (disableAttributesFilter) {\n      return attributes;\n    }\n    // 获取冒号前字符串模糊查询\n    const fuzzyValue = /(.*?)(:|：).*/.test(inputValue)\n      ? RegExp.$1\n      : inputValue;\n    return attributes.filter(\n      (item) => item.name.includes(inputValue) || item.name.includes(fuzzyValue)\n    );\n  }\n\n  getAttribute(selectIndex: number) {\n    const list = this.getUseableList();\n    if (selectIndex < list.length) {\n      return list[selectIndex];\n    }\n  }\n\n  move = (step: number) => {\n    const list = this.getUseableList();\n    if (list.length <= 0) return;\n    this.setState((prevState) => ({\n      select: (prevState.select + step + list.length) % list.length,\n    }));\n  };\n\n  handleKeyDown = (keyCode: string) => {\n    if (!keys[keyCode]) return;\n\n    const { onSelect } = this.props;\n    const { select } = this.state;\n\n    switch (keys[keyCode]) {\n      case \"enter\":\n      case \"tab\":\n        if (select < 0) break;\n        if (onSelect) {\n          onSelect(this.getAttribute(select)!);\n        }\n        return false;\n      case \"up\":\n        this.move(-1);\n        break;\n      case \"down\":\n        this.move(1);\n        break;\n    }\n  };\n\n  handleClick = (index: number) => {\n    const { onSelect } = this.props;\n    if (onSelect) {\n      onSelect(this.getAttribute(index)!);\n    }\n  };\n\n  render() {\n    const { maxHeight } = this.props;\n    const { select } = this.state;\n    const { attributesSelectTips } = this.context;\n\n    const list = this.getUseableList().map((item, index) => (\n      <CommandItem\n        key={index}\n        onSelect={(e) => this.handleClick(index)}\n        className={cn(\n          \"flex cursor-pointer items-center rounded-sm px-2 py-1.5 text-sm outline-none\",\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n          select === index && \"bg-accent text-accent-foreground\"\n        )}\n      >\n        {item.name}\n      </CommandItem>\n    ));\n\n    if (list.length === 0) return null;\n\n    return (\n      <DropdownMenu>\n        <Command style={{ maxHeight: maxHeight }}>\n          <CommandGroup>\n            {attributesSelectTips && (\n              <CommandItem disabled>{attributesSelectTips}</CommandItem>\n            )}\n            {list}\n          </CommandGroup>\n        </Command>\n      </DropdownMenu>\n    );\n  }\n}\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/AttributeSelect.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/TagSearchboxContext.ts",
      "content": "import { createContext } from \"react\";\n\nexport interface TagSearchBoxContextValue {\n  attributesSelectTips?: string;\n  disableAttributesFilter?: boolean;\n  close?: () => void;\n}\n\nexport const TagSearchBoxContext = createContext<TagSearchBoxContextValue>({});\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/TagSearchboxContext.ts"
    },
    {
      "path": "src/registry/new-york/tag-search-box/valueselect/ValueSelect.tsx",
      "content": "import React, { Component } from \"react\";\nimport { PureInput } from \"@/registry/new-york/tag-search-box/valueselect/PureInput\";\nimport { SingleValueSelect } from \"@/registry/new-york/tag-search-box/valueselect/SingleValueSelect\";\nimport { MultipleValueSelect } from \"@/registry/new-york/tag-search-box/valueselect/MultipleValueSelect\";\nimport { AttributeValue } from \"@/registry/new-york/tag-search-box/AttributeSelect\";\nimport { Value } from \"@/registry/new-york/tag-search-box/AttributeSelect\";\nimport { DropdownMenu } from \"@/components/ui/dropdown-menu\";\nimport { Loading } from \"@/registry/new-york/tag-search-box/valueselect/Loading\";\nimport { Empty } from \"@/registry/new-york/tag-search-box/valueselect/Empty\";\n\ninterface ValueSelectProps {\n  /**\n   * 值选择组件类型，用于选择不同组件\n   */\n  type: AttributeValue[\"type\"];\n  /**\n   * 值选择组件可选值的集合\n   */\n  values?: AttributeValue[\"values\"];\n  /**\n   * 当前输入值\n   */\n  inputValue: string;\n  /**\n   * 自定义渲染\n   */\n  render?: AttributeValue[\"render\"];\n  onChange?: (value: Value[]) => void;\n  onSelect?: (value: Value[]) => void;\n  onCancel?: () => void;\n  offset: number;\n  maxHeight: number;\n}\n\ninterface ValueSelectRef {\n  handleKeyDown: (keyCode: string | number) => boolean | void;\n  handleKeyDownForRenderMode: (operationalKey: string) => boolean;\n}\n\ninterface ValueSelectState {\n  values: any[];\n}\n\nexport class ValueSelect extends Component<\n  ValueSelectProps & {\n    forwardRef?: React.Ref<ValueSelectRef>;\n  },\n  ValueSelectState\n> {\n  private mount: boolean = false;\n  private select: any = null;\n  private operationalKeyDownListener: (key: string) => void = () => {};\n\n  constructor(props: ValueSelectProps) {\n    super(props);\n    this.state = {\n      values: Array.isArray(props.values) ? props.values : [],\n    };\n  }\n\n  componentDidMount() {\n    this.mount = true;\n    const { values: propsValues } = this.props;\n\n    if (typeof propsValues === \"function\") {\n      const result = propsValues();\n\n      // Promise处理\n      if (result && \"then\" in result) {\n        result.then((fetchedValues) => {\n          if (this.mount) {\n            this.setState({ values: fetchedValues });\n          }\n        });\n      } else {\n        if (this.mount) {\n          this.setState({ values: result });\n        }\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.mount = false;\n  }\n\n  handleKeyDown = (keyCode: string | number) => {\n    if (this.select && this.select.handleKeyDown) {\n      return this.select.handleKeyDown(keyCode);\n    }\n    return true;\n  };\n\n  handleKeyDownForRenderMode = (operationalKey: string) => {\n    if (this.props.render) {\n      this.operationalKeyDownListener(operationalKey);\n    }\n    return true;\n  };\n\n  render() {\n    const { values } = this.state;\n    const {\n      type,\n      inputValue,\n      onChange,\n      onSelect,\n      onCancel,\n      offset = 0,\n      maxHeight,\n      render,\n    } = this.props;\n\n    // 如果提供了自定义渲染函数\n    if (render) {\n      return (\n        <DropdownMenu>\n          {render({\n            onOperationalKeyDown: (listener) => {\n              this.operationalKeyDownListener = listener as any;\n            },\n            inputValue,\n            onSelect: onSelect!,\n            onCancel: onCancel!,\n          })}\n        </DropdownMenu>\n      );\n    }\n\n    // 处理组件类型\n    let typeOptions: [string, any];\n\n    if (Array.isArray(type)) {\n      typeOptions = type;\n    } else {\n      typeOptions = [type, {}];\n    }\n\n    const commonProps = {\n      values,\n      inputValue,\n      onChange,\n      onSelect,\n      onCancel,\n      offset,\n      maxHeight,\n    };\n\n    // 根据不同类型渲染不同组件\n    switch (typeOptions[0]) {\n      case \"input\":\n        // PureInput requires all callbacks to be non-optional\n        const inputProps = {\n          values,\n          inputValue: inputValue || \"\",\n          onChange: onChange || (() => {}),\n          onSelect: onSelect || (() => {}),\n          onCancel: onCancel || (() => {}),\n          offset,\n          maxHeight,\n        };\n        return (\n          <PureInput\n            ref={(select) => (this.select = select) as any}\n            {...inputProps}\n          />\n        );\n\n      case \"single\":\n        const singleOptions = typeOptions[1];\n\n        if (!Array.isArray(values)) {\n          return <Loading offset={offset} />;\n        }\n\n        if (!values.length) {\n          return (\n            <Empty {...singleOptions} offset={offset} onCancel={onCancel} />\n          );\n        }\n\n        return (\n          <SingleValueSelect\n            {...commonProps}\n            {...singleOptions}\n            ref={(select) => (this.select = select)}\n          />\n        );\n\n      case \"multiple\":\n        const multipleOptions = typeOptions[1];\n\n        if (!Array.isArray(values)) {\n          return <Loading offset={offset} />;\n        }\n\n        if (!values.length) {\n          return (\n            <Empty {...multipleOptions} offset={offset} onCancel={onCancel} />\n          );\n        }\n\n        return (\n          <MultipleValueSelect\n            {...commonProps}\n            {...multipleOptions}\n            ref={(select) => (this.select = select)}\n          />\n        );\n\n      default:\n        return null;\n    }\n  }\n}\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/valueselect/ValueSelect.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/valueselect/PureInput.tsx",
      "content": "import { useEffect, forwardRef, useImperativeHandle } from \"react\";\n\nconst keys: Record<string, string> = {\n  \"9\": \"tab\",\n  \"13\": \"enter\",\n};\n\nconst getValue = (value: string) => {\n  return value.split(\"|\").map((item) => ({\n    name: item.trim(),\n  }));\n};\n\nexport interface PureInputProps {\n  inputValue: string;\n  onChange: (value: any[]) => void;\n  onSelect: (value: any[]) => void;\n}\n\ninterface PureInputRef {\n  handleKeyDown: (keyCode: string) => boolean;\n}\n\nexport const PureInput = forwardRef<PureInputRef, PureInputProps>(\n  ({ onChange, inputValue, onSelect }, ref) => {\n    useEffect(() => {\n      // 编辑完成时 inputValue 被置空，此时 onChange 会导致标签键寻找失败\n      if (inputValue.trim()) {\n        onChange(getValue(inputValue));\n      }\n    }, [inputValue, onChange]);\n\n    const handleKeyDown = (keyCode: string) => {\n      if (!keys[keyCode]) {\n        return false;\n      }\n\n      switch (keys[keyCode]) {\n        case \"tab\":\n        case \"enter\":\n          if (inputValue.length <= 0) return false;\n\n          if (onSelect) {\n            onSelect(getValue(inputValue).filter((i) => !!i.name));\n          }\n          return false;\n      }\n      return false;\n    };\n\n    useImperativeHandle(ref, () => ({\n      handleKeyDown,\n    }));\n\n    return null;\n  }\n);\n\nPureInput.displayName = \"PureInput\";\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/valueselect/PureInput.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/valueselect/SingleValueSelect.tsx",
      "content": "import React, { Component } from \"react\";\nimport { searchFilter } from \"@/registry/new-york/tag-search-box/utils/SearchFilter\";\n\nimport {\n  Card,\n  CardContent\n} from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport { Value } from \"@/registry/new-york/tag-search-box/AttributeSelect\";\n\nconst keys: Record<string, string> = {\n  \"8\": \"backspace\",\n  \"9\": \"tab\",\n  \"13\": \"enter\",\n  \"37\": \"left\",\n  \"38\": \"up\",\n  \"39\": \"right\",\n  \"40\": \"down\",\n};\n\ninterface SingleValueSelectProps {\n    values: Value[];\n    inputValue: string;\n    onChange?: (value: Value[]) => void;\n    onSelect?: (value: Value[]) => void;\n    offset: number;\n    maxHeight: number;\n    /**\n     * 是否支持搜索\n     * @default false\n     * @since 2.5.0\n     */\n    searchable?: boolean;\n    /**\n     * 列表最大宽度\n     * @since 2.7.9\n     */\n    maxWidth?: number | string;\n    /**\n     * 自定义渲染项\n     * @since 2.7.9\n     */\n    itemRender?: (text: string, value: Value) => React.ReactNode;\n}\n\ninterface SingleValueSelectRef {\n  handleKeyDown: (keyCode: string | number) => boolean | undefined;\n}\n\ninterface SingleValueSelectState {\n  select: number;\n  searchValue: string;\n}\n\nclass SingleValueSelect extends Component<SingleValueSelectProps, SingleValueSelectState> {\n  constructor(props: SingleValueSelectProps) {\n    super(props);\n    \n    // Initialize selection\n    let selectIndex = -1;\n    props.values.forEach((item, index) => {\n      if (item.name === props.inputValue) {\n        selectIndex = index;\n      }\n    });\n\n\n    this.state = {\n      select: selectIndex,\n      searchValue: \"\"\n    };\n  }\n\n  componentDidMount() {\n    const { select } = this.state;\n    const { onSelect } = this.props;\n    \n    if (select < 0 && onSelect) {\n      onSelect(this.getValue(select));\n    }\n  }\n\n  static getDerivedStateFromProps(props: SingleValueSelectProps) {\n    const list = props.values.map(item => item.name);\n    const select = list.indexOf(props.inputValue);\n    return { select };\n  }\n\n  getValue = (selectIndex: number) => {\n    if (selectIndex < 0) return [];\n    \n    const { values, inputValue } = this.props;\n    const list = values;\n    \n    if (selectIndex < list.length) {\n      return [list[selectIndex]];\n    } else {\n      const newSelectIndex = list.map(item => item.name).indexOf(inputValue);\n      this.setState({ select: newSelectIndex });\n      \n      if (newSelectIndex < 0) return [];\n      return [list[newSelectIndex]];\n    }\n  };\n\n  handleKeyDown = (keyCode: string | number) => {\n    if (!keys[keyCode as keyof typeof keys]) return;\n\n    const { onSelect } = this.props;\n    const { select } = this.state;\n\n    switch (keys[keyCode as keyof typeof keys]) {\n      case \"enter\":\n      case \"tab\":\n        if (onSelect) {\n          onSelect(this.getValue(select));\n        }\n        return false;\n      \n      case \"up\":\n        this.move(-1);\n        break;\n      \n      case \"down\":\n        this.move(1);\n        break;\n    }\n  };\n\n  move = (step: number) => {\n    const { values } = this.props;\n    const list = values;\n    if (list.length <= 0) return;\n    \n    this.setState(prevState => ({\n      select: (prevState.select + step + list.length) % list.length\n    }));\n  };\n\n  handleClick = (e: React.MouseEvent, index: number) => {\n    e.stopPropagation();\n    const { onSelect } = this.props;\n    if (onSelect) {\n      onSelect(this.getValue(index));\n    }\n  };\n\n  render() {\n    const { select, searchValue } = this.state;\n    const {\n      values,\n      offset = 0,\n      maxHeight = 300,\n      searchable = false,\n      maxWidth,\n      itemRender = (x) => x\n    } = this.props;\n\n    const filteredItems = values\n      .map((item, index) => ({ ...item, index }))\n      .filter(({ name }) => searchFilter(name, searchValue))\n      .map(({ index, ...item }) => (\n        <div \n          key={index} \n          className={cn(\n            \"px-3 py-2 cursor-pointer text-sm rounded-md transition-colors\",\n            select === index \n              ? \"bg-blue-100 text-blue-900\" \n              : \"hover:bg-slate-100\"\n          )}\n          onClick={(e) => this.handleClick(e, index)}\n        >\n          <span \n            title={item.name} \n            style={item.style || {}}\n            className=\"block truncate\"\n          >\n            {itemRender(item.name, item)}\n          </span>\n        </div>\n      ));\n\n    return (\n      <Card \n        className=\"border-none shadow-none py-0\"\n        style={{ \n          maxWidth: maxWidth || 300\n        }}\n        onClick={(e) => e.stopPropagation()}\n      >\n        {searchable && (\n          <div className=\"p-2 border-b\">\n            <Input\n              placeholder=\"搜索...\"\n              value={searchValue}\n              onChange={(e) => this.setState({ searchValue: e.target.value })}\n              className=\"h-8\"\n            />\n          </div>\n        )}\n        \n        <CardContent className=\"p-1\">\n          <ScrollArea className=\"h-full\" style={{ maxHeight: maxHeight }}>\n            <div className=\"space-y-1 py-1\">\n              {filteredItems.length === 0 ? (\n                <div className=\"flex items-center justify-center p-4 text-sm text-slate-500\">\n                  没有匹配的结果\n                </div>\n              ) : (\n                filteredItems\n              )}\n            </div>\n          </ScrollArea>\n        </CardContent>\n      </Card>\n    );\n  }\n}\n\n// Create a forwardRef wrapper to maintain the ref functionality\nconst SingleValueSelectWithRef = React.forwardRef<SingleValueSelectRef, SingleValueSelectProps>((props, ref) => {\n  const componentRef = React.useRef<SingleValueSelect>(null);\n\n  React.useImperativeHandle(ref, () => ({\n    handleKeyDown: (keyCode: string | number) => {\n      return componentRef.current?.handleKeyDown(keyCode);\n    }\n  }));\n\n  return <SingleValueSelect {...props} ref={componentRef} />;\n});\n\nexport { SingleValueSelectWithRef as SingleValueSelect };",
      "type": "registry:component",
      "target": "src/components/tag-search-box/valueselect/SingleValueSelect.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/valueselect/MultipleValueSelect.tsx",
      "content": "import React, { Component } from \"react\";\nimport { searchFilter } from \"@/registry/new-york/tag-search-box/utils/SearchFilter\";\n\nimport { Card, CardContent, CardFooter } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Input } from \"@/components/ui/input\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport { Value } from \"@/registry/new-york/tag-search-box/AttributeSelect\";\n\nconst keys: Record<string, string> = {\n  \"8\": \"backspace\",\n  \"9\": \"tab\",\n  \"13\": \"enter\",\n  \"37\": \"left\",\n  \"38\": \"up\",\n  \"39\": \"right\",\n  \"40\": \"down\",\n};\n\ninterface IMultipleValueSelectProps {\n  values: Value[];\n  inputValue: string;\n  onChange: (value: Value[]) => void;\n  onSelect: (value: Value[]) => void;\n  onCancel: () => void;\n  offset: number;\n  maxHeight: number;\n  /**\n   * 是否支持全选\n   * @default true\n   */\n  all?: boolean;\n  /**\n   * 是否支持搜索\n   * @default false\n   * @since 2.5.0\n   */\n  searchable?: boolean;\n  /**\n   * 列表最大宽度\n   * @since 2.7.9\n   */\n  maxWidth?: number | string;\n  /**\n   * 自定义渲染项\n   * @since 2.7.9\n   */\n  itemRender?: (text: string, value: Value) => React.ReactNode;\n}\n\ninterface IMultipleValueSelectRef {\n  handleKeyDown: (keyCode: string | number) => boolean | undefined;\n}\n\ninterface IMultipleValueSelectState {\n  curIndex: number;\n  select: number[];\n  searchValue: string;\n  lastInputValue: string;\n}\n\nclass IMultipleValueSelect extends Component<\n  IMultipleValueSelectProps,\n  IMultipleValueSelectState\n> {\n  constructor(props: IMultipleValueSelectProps) {\n    super(props);\n\n    // Initialize selection\n    const list = props.inputValue.split(\"|\").map((i) => i.trim());\n    const select: number[] = [];\n\n    const formattedValues = props.values.map((item) => ({\n      ...item,\n      name: item.name.trim(),\n    }));\n\n    formattedValues.forEach((item, index) => {\n      if (list.indexOf(item.name) >= 0) {\n        select.push(index);\n      }\n    });\n\n    this.state = {\n      curIndex: 0,\n      select,\n      searchValue: \"\",\n      lastInputValue: props.inputValue,\n    };\n  }\n\n  componentDidMount() {\n    const { select } = this.state;\n    const { onSelect } = this.props;\n\n    if (select.length <= 0 && onSelect) {\n      onSelect(this.getValue(select));\n    }\n  }\n\n  static getDerivedStateFromProps(\n    props: IMultipleValueSelectProps,\n    state: IMultipleValueSelectState\n  ) {\n    if (state.lastInputValue !== props.inputValue) {\n      const list = props.inputValue.split(\"|\").map((i) => i.trim());\n      const select: number[] = [];\n\n      const formattedValues = props.values.map((item) => ({\n        ...item,\n        name: item.name.trim(),\n      }));\n\n      formattedValues.forEach((item, index) => {\n        if (list.indexOf(item.name) >= 0) {\n          select.push(index);\n        }\n      });\n\n      return { select, lastInputValue: props.inputValue };\n    }\n    return null;\n  }\n\n  getValue = (selectedIndexes: number[]) => {\n    return selectedIndexes.map((i) => this.props.values[i]);\n  };\n\n  handleKeyDown = (keyCode: string | number) => {\n    if (!keys[keyCode as keyof typeof keys]) return;\n\n    const { curIndex, select } = this.state;\n    const { onChange, onSelect } = this.props;\n\n    switch (keys[keyCode as keyof typeof keys]) {\n      case \"tab\":\n        if (curIndex < 0) return false;\n        if (curIndex === 0) {\n          this.handleSelectAll();\n          return false;\n        }\n\n        const newSelect = [...select];\n        const pos = newSelect.indexOf(curIndex - 1);\n\n        if (pos >= 0) {\n          newSelect.splice(pos, 1);\n        } else {\n          newSelect.push(curIndex - 1);\n        }\n\n        this.setState({ select: newSelect });\n        onChange?.(this.getValue(newSelect));\n        return false;\n\n      case \"enter\":\n        onSelect?.(this.getValue(select));\n        return false;\n\n      case \"up\":\n        this.move(-1);\n        break;\n\n      case \"down\":\n        this.move(1);\n        break;\n    }\n  };\n\n  move = (step: number) => {\n    const { values } = this.props;\n    if (values.length <= 0) return;\n\n    this.setState((prevState) => ({\n      curIndex:\n        (prevState.curIndex + step + (values.length + 1)) % (values.length + 1),\n    }));\n  };\n\n  handleClick = (e: React.MouseEvent, index: number) => {\n    e.stopPropagation();\n\n    if (\n      (e.target as HTMLElement).tagName === \"LABEL\" ||\n      (e.target as HTMLElement).tagName === \"SPAN\"\n    ) {\n      return;\n    }\n\n    const { select } = this.state;\n    const { onChange } = this.props;\n    const newSelect = [...select];\n    const pos = newSelect.indexOf(index);\n\n    if (pos >= 0) {\n      newSelect.splice(pos, 1);\n    } else {\n      newSelect.push(index);\n    }\n\n    this.setState({ select: newSelect });\n    onChange?.(this.getValue(newSelect));\n  };\n\n  handleSelectAll = (e?: React.MouseEvent) => {\n    e?.stopPropagation();\n    const { select } = this.state;\n    const { values, onChange } = this.props;\n\n    if (select.length === values.length) {\n      this.setState({ select: [] });\n      onChange?.([]);\n    } else {\n      const newSelect = values.map((_, index) => index);\n      this.setState({ select: newSelect });\n      onChange?.(values);\n    }\n  };\n\n  handleSubmit = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    const { select } = this.state;\n    const { onSelect } = this.props;\n    onSelect?.(this.getValue(select));\n  };\n\n  handleCancel = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    const { onCancel } = this.props;\n    onCancel?.();\n  };\n\n  render() {\n    const { curIndex, select, searchValue } = this.state;\n    const {\n      values,\n      offset = 0,\n      all = true,\n      maxHeight = 350,\n      searchable = false,\n      maxWidth,\n      itemRender = (x) => x,\n    } = this.props;\n\n    const filteredItems = values\n      .map((item, index) => ({ ...item, index }))\n      .filter(({ name }) => searchFilter(name, searchValue))\n      .map(({ index, ...item }) => (\n        <div\n          key={index}\n          className={cn(\n            \"flex items-center p-2 rounded-md cursor-pointer hover:bg-slate-100 transition-colors\",\n            curIndex === index + 1 ? \"bg-slate-100\" : \"\"\n          )}\n          onClick={(e) => this.handleClick(e, index)}\n        >\n          <div className=\"flex items-center gap-2\">\n            <Checkbox\n              checked={select.indexOf(index) >= 0}\n              id={`item-${index}`}\n              className=\"data-[state=checked]:bg-blue-500\"\n            />\n            <label\n              htmlFor={`item-${index}`}\n              className=\"text-sm cursor-pointer\"\n              style={item.style || {}}\n              title={item.name}\n            >\n              {itemRender(item.name, item)}\n            </label>\n          </div>\n        </div>\n      ));\n\n    return (\n      <Card\n        className=\"w-auto border-none shadow-none py-0 gap-0\"\n        style={{\n          maxWidth: maxWidth || 300,\n        }}\n        onClick={(e) => e.stopPropagation()}\n      >\n        {searchable && (\n          <div className=\"p-2 border-b\">\n            <Input\n              placeholder=\"搜索...\"\n              value={searchValue}\n              onChange={(e) => this.setState({ searchValue: e.target.value })}\n              className=\"h-8\"\n            />\n          </div>\n        )}\n\n        <CardContent className=\"p-0\">\n          <ScrollArea\n            className=\"h-full max-h-[300px]\"\n            style={{ maxHeight: maxHeight - 50 }}\n          >\n            <div className=\"p-1\">\n              {all && !searchValue && (\n                <div\n                  className={cn(\n                    \"flex items-center p-2 rounded-md cursor-pointer hover:bg-slate-100 transition-colors\",\n                    curIndex === 0 ? \"bg-slate-100\" : \"\"\n                  )}\n                  onClick={this.handleSelectAll}\n                >\n                  <div className=\"flex items-center gap-2\">\n                    <Checkbox\n                      checked={select.length === values.length}\n                      id=\"select-all\"\n                      className=\"data-[state=checked]:bg-blue-500\"\n                    />\n                    <label\n                      htmlFor=\"select-all\"\n                      className=\"text-sm font-medium cursor-pointer\"\n                    >\n                      Select All\n                    </label>\n                  </div>\n                </div>\n              )}\n\n              {filteredItems.length === 0 ? (\n                <div className=\"flex items-center justify-center p-4 text-sm text-slate-500\">\n                  没有匹配的结果\n                </div>\n              ) : (\n                filteredItems\n              )}\n            </div>\n          </ScrollArea>\n        </CardContent>\n\n        <CardFooter className=\"flex justify-end p-2 [.border-t]:pt-2 border-t border-gray-200\">\n          <div className=\"flex items-center gap-2\">\n            <Button\n              size=\"sm\"\n              onClick={this.handleSubmit}\n              disabled={select.length === 0}\n              variant=\"default\"\n              className=\"h-7 font-normal text-sm\"\n            >\n              OK\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={this.handleCancel}\n              className=\"h-7 font-normal text-sm\"\n            >\n              Cancel\n            </Button>\n          </div>\n        </CardFooter>\n      </Card>\n    );\n  }\n}\n\n// Create a forwardRef wrapper to maintain the ref functionality\nconst MultipleValueSelect = React.forwardRef<\n  IMultipleValueSelectRef,\n  IMultipleValueSelectProps\n>((props, ref) => {\n  const componentRef = React.useRef<IMultipleValueSelect>(null);\n\n  React.useImperativeHandle(ref, () => ({\n    handleKeyDown: (keyCode: string | number) => {\n      return componentRef.current?.handleKeyDown(keyCode);\n    },\n  }));\n\n  return <IMultipleValueSelect {...props} ref={componentRef} />;\n});\n\nexport { MultipleValueSelect };\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/valueselect/MultipleValueSelect.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/valueselect/Loading.tsx",
      "content": "import React from \"react\";\nimport { DropdownMenu } from \"@/components/ui/dropdown-menu\";\nimport { CommandList, CommandItem } from \"@/components/ui/command\";\n\ninterface LoadingProps {\n  offset: number;\n}\n\nexport const Loading = React.forwardRef<HTMLDivElement, LoadingProps>(\n  ({ offset }, ref) => {\n    return (\n      <DropdownMenu>\n        <CommandList>\n          <CommandItem>Loading...</CommandItem>\n        </CommandList>\n      </DropdownMenu>\n    );\n  }\n);\n\nLoading.displayName = \"Loading\";\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/valueselect/Loading.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/valueselect/Empty.tsx",
      "content": "import React from \"react\";\nimport { DropdownMenu } from \"@/components/ui/dropdown-menu\";\nimport { CommandEmpty, CommandList } from \"@/components/ui/command\";\n\ninterface EmptyProps {\n  offset: number;\n  onCancel: () => void;\n  emptyText: string;\n}\n\nexport const Empty = React.forwardRef<HTMLDivElement, EmptyProps>(\n  ({ offset, onCancel, emptyText }, ref) => {\n    return (\n      <DropdownMenu>\n        <CommandList>\n          <CommandEmpty onClick={onCancel}>{emptyText || \"Empty\"}</CommandEmpty>\n        </CommandList>\n      </DropdownMenu>\n    );\n  }\n);\n\nEmpty.displayName = \"Empty\";\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/valueselect/Empty.tsx"
    },
    {
      "path": "src/registry/new-york/tag-search-box/utils/SearchFilter.ts",
      "content": "export function searchFilter(optionValue: string, inputValue: string) {\n    return String(optionValue)\n      .trim()\n      .toLowerCase()\n      .includes(String(inputValue).trim().toLowerCase());\n  }\n  ",
      "type": "registry:component",
      "target": "src/components/tag-search-box/utils/SearchFilter.ts"
    },
    {
      "path": "src/registry/new-york/tag-search-box/utils/MergeRefs.ts",
      "content": "import { MutableRefObject, LegacyRef } from 'react';\n\n\n/**\n * 合并多个 refs 到一个回调函数中\n * @param refs 要合并的 refs 数组\n * @returns 合并后的 ref 回调函数\n */\nexport function mergeRefs<T = any>(...refs: Array<LegacyRef<T> | undefined>): (instance: T | null) => void {\n  return (instance: T | null) => {\n    for (const ref of refs) {\n      if (typeof ref === 'function') {\n        ref(instance);\n      } else if (ref && typeof ref === 'object') {\n        try {\n          (ref as MutableRefObject<T | null>).current = instance;\n        } catch (_) {\n          // ignore\n        }\n      }\n    }\n  };\n}",
      "type": "registry:component",
      "target": "src/components/tag-search-box/utils/MergeRefs.ts"
    },
    {
      "path": "src/registry/new-york/tag-search-box/utils/withOutsideClick.tsx",
      "content": "import React, { forwardRef, ComponentType, Component, Ref } from \"react\";\n\nexport interface OutsideClickConfig {\n  ignoreClasses?: string[];\n\n  disabled?: boolean;\n\n  enableOnClickOutside?: boolean;\n}\n\ntype BaseProps = {\n  forwardedRef?: Ref<any>;\n  disabled?: boolean;\n};\n\nexport function withOutsideClick(methodName: string) {\n  return function <P extends object>(\n    WrappedComponent: ComponentType<P>,\n    config: OutsideClickConfig = {}\n  ) {\n    const {\n      ignoreClasses = [],\n      disabled: defaultDisabled = false,\n      enableOnClickOutside = true,\n    } = config;\n\n    type Props = P & BaseProps;\n\n    class OutsideClickWrapper extends Component<Props> {\n      private instance: any;\n      private __clickOutsideHandlerProp: string;\n      private __outsideClickIgnoreClass: string[];\n      private __disabled: boolean;\n      private __enableOnClickOutside: boolean;\n\n      constructor(props: Props) {\n        super(props);\n        this.__clickOutsideHandlerProp = methodName;\n        this.__outsideClickIgnoreClass = ignoreClasses;\n        this.__disabled = props.disabled ?? defaultDisabled;\n        this.__enableOnClickOutside = enableOnClickOutside;\n        this.instance = null;\n      }\n\n      componentDidMount() {\n        if (this.__enableOnClickOutside) {\n          this.enableOnClickOutside();\n        }\n      }\n\n      componentDidUpdate(prevProps: Props) {\n        if (this.props.disabled !== prevProps.disabled) {\n          this.__disabled = this.props.disabled ?? defaultDisabled;\n          if (this.__disabled) {\n            this.disableOnClickOutside();\n          } else {\n            this.enableOnClickOutside();\n          }\n        }\n      }\n\n      componentWillUnmount() {\n        this.disableOnClickOutside();\n      }\n\n      private handleClickOutside = (event: MouseEvent | TouchEvent) => {\n        if (this.__disabled) {\n          return;\n        }\n\n        const target = event.target as Element;\n        if (this.isIgnoredElement(target)) {\n          return;\n        }\n\n        if (this.instance.searchWrapRef.current?.contains(target)) {\n          return;\n        }\n\n        if (\n          this.instance &&\n          typeof this.instance[this.__clickOutsideHandlerProp] === \"function\"\n        ) {\n          this.instance[this.__clickOutsideHandlerProp](event);\n        }\n      };\n\n      private isIgnoredElement = (element: Element | null): boolean => {\n        if (!element) return false;\n\n        if (\n          this.__outsideClickIgnoreClass.some((className) =>\n            element.classList.contains(className)\n          )\n        ) {\n          return true;\n        }\n\n        return this.isIgnoredElement(element.parentElement);\n      };\n\n      private enableOnClickOutside = () => {\n        document.addEventListener(\"mousedown\", this.handleClickOutside);\n        document.addEventListener(\"touchstart\", this.handleClickOutside);\n      };\n\n      private disableOnClickOutside = () => {\n        document.removeEventListener(\"mousedown\", this.handleClickOutside);\n        document.removeEventListener(\"touchstart\", this.handleClickOutside);\n      };\n\n      render() {\n        const { forwardedRef, ...rest } = this.props;\n\n        return (\n          <WrappedComponent\n            {...(rest as P)}\n            ref={(instance: any) => {\n              this.instance = instance;\n              if (typeof forwardedRef === \"function\") {\n                forwardedRef(instance);\n              } else if (forwardedRef) {\n                (forwardedRef as React.MutableRefObject<any>).current =\n                  instance;\n              }\n            }}\n          />\n        );\n      }\n    }\n\n    const ForwardedOutsideClickWrapper = forwardRef<\n      any,\n      Omit<P, \"ref\"> & { disabled?: boolean }\n    >((props, ref) => {\n      // @ts-ignore\n      return <OutsideClickWrapper {...props} forwardedRef={ref} />;\n    });\n\n    return ForwardedOutsideClickWrapper;\n  };\n}\n",
      "type": "registry:component",
      "target": "src/components/tag-search-box/utils/withOutsideClick.tsx"
    }
  ]
}